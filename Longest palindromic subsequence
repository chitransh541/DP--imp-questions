// first the recursive appraoch..

class Solution {
    public int helper(String str,String rev,int i,int j)
    {
        if(i>=str.length() || j>=rev.length())
        {
            return 0;
        }
        int include=0;
        if(str.charAt(i)==rev.charAt(j))
        {
            return 1+helper(str,rev,i+1,j+1);
        }
        int option1 = helper(str,rev,i+1,j);
        int option2 = helper(str,rev,i,j+1);
        return Math.max(option1,option2);

    }
    public int longestPalindromeSubseq(String s) {
        String str = s;
        StringBuilder sb = new StringBuilder(s);
       sb.reverse();
        String rev = sb.toString();
        return helper(str,rev,0,0);
    }
} 

// now optimize it with memoization...

class Solution {
    public int helper(String str,String rev,int i,int j,int[][] dp)
    {
        if(i>=str.length() || j>=rev.length())
        {
            return 0;
        }
        int include=0;
        if(dp[i][j]!=-1)
        {
            return dp[i][j];
        }
        if(str.charAt(i)==rev.charAt(j))
        {
            dp[i][j] =  1+helper(str,rev,i+1,j+1,dp);
        }
        else
        {
            int option1 = helper(str,rev,i+1,j,dp);
            int option2 = helper(str,rev,i,j+1,dp);
            dp[i][j] =  Math.max(option1,option2);
        }
        return dp[i][j];

    }
    public int longestPalindromeSubseq(String s) {
        String str = s;
        StringBuilder sb = new StringBuilder(s);
       sb.reverse();
       int n = s.length();
       int[][] dp = new int[n+1][n+1];
       for(int i=0;i<n;i++)
       {
        for(int j=0;j<n;j++)
        {
            dp[i][j] = -1;
        }
       }
        String rev = sb.toString();
        return helper(str,rev,0,0,dp);
    }
}
